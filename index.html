<!DOCTYPE html>
<html lang="cs">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Editor doch√°zky</title>
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            background-color: var(--tg-theme-bg-color, #ffffff);
            color: var(--tg-theme-text-color, #000000);
            padding: 16px;
            padding-bottom: 80px;
            min-height: 100vh;
        }

        .container {
            max-width: 600px;
            margin: 0 auto;
            width: 100%;
        }

        .header {
            margin-bottom: 20px;
            text-align: center;
        }

        .header h1 {
            font-size: 24px;
            font-weight: 600;
            margin-bottom: 12px;
        }

        .date-picker {
            margin-bottom: 24px;
        }

        .date-picker label {
            display: block;
            font-size: 14px;
            font-weight: 500;
            margin-bottom: 8px;
            color: var(--tg-theme-hint-color, #999999);
        }

        .date-picker input {
            width: 100%;
            padding: 12px;
            font-size: 16px;
            border: 1px solid var(--tg-theme-hint-color, #cccccc);
            border-radius: 12px;
            background-color: var(--tg-theme-bg-color, #ffffff);
            color: var(--tg-theme-text-color, #000000);
            transition: border-color 0.2s;
        }

        .date-picker input:focus {
            border-color: var(--tg-theme-button-color, #0088cc);
            outline: none;
        }

        .attendance-records {
            margin-bottom: 24px;
        }

        .record-card {
            background-color: var(--tg-theme-secondary-bg-color, #f0f0f0);
            border-radius: 16px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.05);
        }

        .record-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 16px;
        }

        .record-title {
            font-size: 17px;
            font-weight: 600;
        }

        .remove-record-btn {
            background-color: transparent;
            color: var(--tg-theme-destructive-text-color, #ff3b30);
            border: 1px solid var(--tg-theme-destructive-text-color, #ff3b30);
            padding: 6px 12px;
            border-radius: 8px;
            font-size: 13px;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .remove-record-btn:active {
            opacity: 0.7;
            transform: scale(0.98);
        }

        .time-inputs {
            display: flex;
            gap: 12px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .time-group {
            display: flex;
            flex-direction: column;
            flex: 1;
            min-width: 120px;
        }

        .time-group label {
            font-size: 13px;
            font-weight: 500;
            margin-bottom: 6px;
            color: var(--tg-theme-hint-color, #999999);
        }

        .time-group input {
            padding: 12px;
            font-size: 16px; /* Prevents zoom on iOS */
            border: 1px solid var(--tg-theme-hint-color, #cccccc);
            border-radius: 10px;
            background-color: var(--tg-theme-bg-color, #ffffff);
            color: var(--tg-theme-text-color, #000000);
            width: 100%;
        }

        .breaks-section {
            margin-top: 16px;
            padding-top: 16px;
            border-top: 1px solid rgba(0,0,0,0.1);
        }

        .breaks-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
        }

        .breaks-title {
            font-size: 15px;
            font-weight: 600;
        }

        .add-break-btn {
            background-color: rgba(0, 136, 204, 0.1);
            color: var(--tg-theme-button-color, #0088cc);
            border: none;
            padding: 8px 12px;
            border-radius: 8px;
            font-size: 13px;
            font-weight: 500;
            cursor: pointer;
        }

        .break-item {
            background-color: var(--tg-theme-bg-color, #ffffff);
            border-radius: 12px;
            padding: 12px;
            margin-bottom: 10px;
        }

        .break-time-inputs {
            display: flex;
            gap: 10px;
            align-items: flex-end;
            flex-wrap: wrap;
        }
        
        .break-time-inputs .time-group {
            flex: 1 1 100px; /* Grow, Shrink, Base width */
        }

        .remove-break-btn {
            background-color: rgba(255, 59, 48, 0.1);
            color: var(--tg-theme-destructive-text-color, #ff3b30);
            border: none;
            padding: 12px;
            border-radius: 8px;
            font-size: 13px;
            cursor: pointer;
            height: 45px; /* Match input height approx */
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .add-record-btn {
            width: 100%;
            background-color: var(--tg-theme-button-color, #0088cc);
            color: var(--tg-theme-button-text-color, #ffffff);
            border: none;
            padding: 16px;
            border-radius: 12px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            margin-bottom: 24px;
            box-shadow: 0 4px 12px rgba(0, 136, 204, 0.2);
            transition: transform 0.2s;
        }
        
        .add-record-btn:active {
            transform: scale(0.98);
        }

        .button-group {
            display: flex;
            gap: 12px;
            margin-bottom: 0;
            position: sticky;
            bottom: 0;
            background-color: var(--tg-theme-bg-color, #ffffff);
            padding: 16px 0;
            z-index: 100;
            border-top: 1px solid rgba(0,0,0,0.05); /* visual separator */
        }
        .button-group button {
            flex: 1;
            margin-bottom: 0; /* Reset margin */
        }

        .save-btn {
            background-color: var(--tg-theme-button-color, #0088cc);
            color: var(--tg-theme-button-text-color, #ffffff);
            border: none;
            padding: 14px;
            border-radius: 12px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: opacity 0.2s;
        }
        .save-btn:active {
            opacity: 0.8;
        }

        .cancel-btn {
            width: 100%;
            background-color: transparent;
            color: var(--tg-theme-destructive-text-color, #ff3b30);
            border: 1px solid var(--tg-theme-destructive-text-color, #ff3b30);
            padding: 14px;
            border-radius: 12px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            margin-bottom: 24px;
            transition: opacity 0.2s;
        }
        
        .cancel-btn:active {
            opacity: 0.6;
            background-color: rgba(255, 59, 48, 0.05);
        }

        .empty-state {
            text-align: center;
            padding: 60px 20px;
            color: var(--tg-theme-hint-color, #999999);
            background: var(--tg-theme-secondary-bg-color, #f9f9f9);
            border-radius: 16px;
            border: 2px dashed rgba(0,0,0,0.05);
        }

        .empty-state p {
            font-size: 15px;
            margin-bottom: 16px;
        }

        .loading {
            text-align: center;
            padding: 20px;
            color: var(--tg-theme-hint-color, #999999);
        }

        .error {
            background-color: rgba(255, 59, 48, 0.1);
            color: var(--tg-theme-destructive-text-color, #ff3b30);
            padding: 12px;
            border-radius: 12px;
            margin-bottom: 16px;
            font-size: 14px;
            border-left: 4px solid #ff3b30;
        }
        
        .success-message {
            background-color: rgba(52, 199, 89, 0.1);
            color: var(--tg-theme-text-color, #000000);
            padding: 12px;
            border-radius: 12px;
            margin-bottom: 16px;
            font-size: 14px;
            border-left: 4px solid #34c759;
        }

        /* Invalid Records Feature Styles */
        .fix-btn {
            background-color: rgba(255, 149, 0, 0.1);
            color: #ff9500;
            border: 1px solid #ff9500;
            padding: 8px 12px;
            border-radius: 8px;
            font-size: 13px;
            font-weight: 600;
            cursor: pointer;
            margin-top: 10px;
            display: none; /* Hidden by default */
            width: 100%;
        }
        
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.5);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }
        
        .modal {
            background: var(--tg-theme-bg-color, #ffffff);
            padding: 20px;
            border-radius: 16px;
            width: 90%;
            max-width: 400px;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 4px 20px rgba(0,0,0,0.2);
        }
        
        .modal h3 {
            margin-bottom: 16px;
            font-size: 18px;
            font-weight: 600;
            text-align: center;
        }
        
        .invalid-date-item {
            padding: 12px;
            border-bottom: 1px solid rgba(0,0,0,0.1);
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .invalid-date-item:last-child {
            border-bottom: none;
        }
        
        .close-modal-btn {
            margin-top: 16px;
            width: 100%;
            padding: 12px;
            background-color: var(--tg-theme-button-color, #0088cc);
            color: var(--tg-theme-button-text-color, #ffffff);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            font-weight: 600;
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
        }
        
        .status-badge {
            font-size: 12px;
            padding: 4px 8px;
            border-radius: 4px;
            margin-left: 8px;
            font-weight: 600;
        }
        .status-valid {
            background-color: rgba(52, 199, 89, 0.2);
            color: #34c759;
        }
        .status-invalid {
            background-color: rgba(255, 59, 48, 0.2);
            color: #ff3b30;
        }

        @media (max-width: 360px) {
            .time-inputs {
                flex-direction: column;
            }
            .break-time-inputs {
                gap: 8px;
            }
            .remove-break-btn {
                width: 100%;
                margin-top: 4px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üìÖ Editor doch√°zky</h1>
            <button id="fix-incomplete-btn" class="fix-btn" onclick="showInvalidDatesModal()">
                ‚ö†Ô∏è Vy≈ôe≈°it nekompletn√≠ z√°znamy
            </button>
        </div>

        <div class="date-picker">
            <label for="date-input">Datum</label>
            <input type="date" id="date-input" />
        </div>

        <div id="status-container"></div>
        <div id="loading-container" class="loading" style="display: none;">Naƒç√≠t√°n√≠...</div>

        <div id="attendance-records-container">
            <div class="empty-state">
                <p>≈Ω√°dn√© z√°znamy doch√°zky</p>
                <p>Kliknƒõte na "P≈ôidat z√°znam" pro vytvo≈ôen√≠ nov√©ho z√°znamu</p>
            </div>
        </div>

        <button class="add-record-btn" onclick="addAttendanceRecord()">+ P≈ôidat z√°znam</button>
        <div class="button-group">
            <button class="save-btn" onclick="saveData(false)">Ulo≈æit</button>
            <button class="cancel-btn" onclick="resetData()">Zru≈°it</button>
        </div>

        <!-- Modal -->
        <div id="invalid-dates-modal" class="modal-overlay">
            <div class="modal">
                <h3>Nekompletn√≠ dny</h3>
                <div id="invalid-dates-list"></div>
                <button class="close-modal-btn" onclick="closeInvalidDatesModal()">Zav≈ô√≠t</button>
            </div>
        </div>
    </div>

    <script>
        // CONFIGURATION
        // REPLACE WITH YOUR ACTUAL API URL (e.g., https://your-app.herokuapp.com)
        // For local development with ngrok: https://xxxx-xx-xx-xx-xx.ngrok-free.app
        const API_BASE_URL = 'https://sedentary-rae-alterably.ngrok-free.dev';

        let tg = window.Telegram.WebApp;
        
        // Debug: Check Telegram WebApp initialization
        console.log('[DEBUG] Telegram WebApp initialized');
        console.log('[DEBUG] tg object:', tg);
        console.log('[DEBUG] tg.initData:', tg.initData);
        console.log('[DEBUG] tg.initData type:', typeof tg.initData);
        console.log('[DEBUG] tg.initData length:', tg.initData ? tg.initData.length : 'undefined/null');
        console.log('[DEBUG] tg.initData preview:', tg.initData ? tg.initData.substring(0, 100) + '...' : 'N/A');
        console.log('[DEBUG] tg.ready:', tg.ready);
        console.log('[DEBUG] tg.version:', tg.version);
        
        // Wait for Telegram WebApp to be ready
        tg.ready();
        
        // Check if we're running inside Telegram
        if (!tg.initData || tg.initData.length === 0) {
            console.warn('[WARNING] tg.initData is not available. This might be because:');
            console.warn('1. App is not opened from Telegram');
            console.warn('2. Telegram WebApp is not fully initialized yet');
            console.warn('3. initData is not available in this context');
        }
        
        tg.expand();
        
        // Setup Main Button (Save)
        tg.MainButton.setText("Ulo≈æit a zav≈ô√≠t");
        tg.MainButton.show();
        tg.MainButton.enable();
        tg.MainButton.onClick(() => saveData(true));
        
        // Remove Back Button if it was enabled
        tg.BackButton.hide();

        let attendanceRecords = [];
        let originalAttendanceRecords = [];
        let currentDate = new Date().toISOString().split('T')[0];
        
        // Initialize
        function initializeApp() {
            const dateInput = document.getElementById('date-input');
            dateInput.value = currentDate;
            dateInput.max = new Date().toISOString().split('T')[0]; // Can't select future dates

            // Fetch data for today immediately
            fetchAttendance(currentDate);
            
            // Check for invalid dates
            fetchInvalidDates();

            // Listen for date changes
            dateInput.addEventListener('change', function(e) {
                const selectedDate = e.target.value;
                if (selectedDate && selectedDate !== currentDate) {
                    currentDate = selectedDate;
                    fetchAttendance(selectedDate);
                }
            });
        }

        // Fetch invalid dates
        async function fetchInvalidDates() {
            if (!tg.initData) return;
            
            try {
                const response = await fetch(`${API_BASE_URL}/api/attendance/invalid`, {
                    headers: {
                        'Authorization': tg.initData,
                        'ngrok-skip-browser-warning': 'true'
                    }
                });
                
                if (response.ok) {
                    const data = await response.json();
                    if (data.invalidDates && data.invalidDates.length > 0) {
                        const btn = document.getElementById('fix-incomplete-btn');
                        btn.style.display = 'block';
                        btn.innerHTML = `‚ö†Ô∏è Vy≈ôe≈°it nekompletn√≠ z√°znamy (${data.invalidDates.length})`;
                        
                        // Populate list
                        const list = document.getElementById('invalid-dates-list');
                        list.innerHTML = data.invalidDates.map(date => `
                            <div class="invalid-date-item" onclick="selectInvalidDate('${date}')">
                                <span>${date}</span>
                                <span style="color: var(--tg-theme-button-color, #0088cc);">Opravit ‚Üí</span>
                            </div>
                        `).join('');
                    } else {
                        document.getElementById('fix-incomplete-btn').style.display = 'none';
                    }
                }
            } catch (e) {
                console.error('Error fetching invalid dates:', e);
            }
        }

        // Show/Hide Modal
        function showInvalidDatesModal() {
            document.getElementById('invalid-dates-modal').style.display = 'flex';
        }
        
        function closeInvalidDatesModal() {
            document.getElementById('invalid-dates-modal').style.display = 'none';
        }
        
        // Select date from modal
        function selectInvalidDate(date) {
            const dateInput = document.getElementById('date-input');
            dateInput.value = date;
            currentDate = date;
            fetchAttendance(date);
            closeInvalidDatesModal();
        }

        // Fetch attendance data from API
        async function fetchAttendance(date) {
            showLoading(true);
            hideStatus();
            
            // Debug: Check initData before making request
            console.log('[DEBUG] fetchAttendance called for date:', date);
            console.log('[DEBUG] tg.initData at fetch time:', tg.initData);
            console.log('[DEBUG] tg.initData is empty?', !tg.initData || tg.initData.length === 0);
            console.log('[DEBUG] tg.initData type:', typeof tg.initData);
            
            if (!tg.initData || tg.initData.length === 0) {
                console.error('[ERROR] tg.initData is empty or undefined!');
                showError('Telegram authentication data is missing. Please open this app from Telegram.');
                showLoading(false);
                return;
            }
            
            try {
                const authHeader = tg.initData || '';
                console.log('[DEBUG] Sending Authorization header length:', authHeader.length);
                console.log('[DEBUG] Authorization header preview:', authHeader.substring(0, 100) + '...');
                console.log('[DEBUG] Full request URL:', `${API_BASE_URL}/api/attendance/${date}`);
                
                const response = await fetch(`${API_BASE_URL}/api/attendance/${date}`, {
                    method: 'GET',
                    headers: {
                        'Authorization': authHeader,
                        'ngrok-skip-browser-warning': 'true'
                    }
                });
                
                if (!response.ok) {
                    // Try to get error message from response
                    const contentType = response.headers.get('content-type');
                    let errorMessage = `HTTP error! Status: ${response.status}`;
                    
                    if (contentType && contentType.includes('application/json')) {
                        try {
                            const errorData = await response.json();
                            errorMessage = errorData.error || errorMessage;
                        } catch (e) {
                            // Ignore JSON parse error
                        }
                    } else {
                        // Server returned HTML or other non-JSON content
                        const text = await response.text();
                        if (text.trim().startsWith('<')) {
                            errorMessage = `Server returned HTML instead of JSON. Is the API server running? (Status: ${response.status})`;
                        } else {
                            errorMessage = `Server error: ${text.substring(0, 100)}`;
                        }
                    }
                    
                    throw new Error(errorMessage);
                }
                
                // Check if response is actually JSON
                const contentType = response.headers.get('content-type');
                if (!contentType || !contentType.includes('application/json')) {
                    const text = await response.text();
                    if (text.trim().startsWith('<')) {
                        throw new Error('Server returned HTML instead of JSON. Please check if the Flask API server is running and the ngrok URL is correct.');
                    } else {
                        throw new Error(`Server returned unexpected content type: ${contentType}`);
                    }
                }
                
                const data = await response.json();
                
                if (data.attendanceRecords) {
                    loadAttendanceData(data.attendanceRecords);
                } else {
                    attendanceRecords = [];
                    renderRecords();
                }
                
            } catch (error) {
                console.error('Error fetching attendance:', error);
                showError(`Nepoda≈ôilo se naƒç√≠st data: ${error.message}`);
            } finally {
                showLoading(false);
            }
        }

        // Load attendance data
        function loadAttendanceData(records) {
            attendanceRecords = records.map(record => ({
                id: record.id || null,
                clock_in: record.clock_in || '',
                clock_out: record.clock_out || '',
                breaks: (record.breaks || []).map(breakItem => ({
                    id: breakItem.id || null,
                    start_time: breakItem.start_time || '',
                    end_time: breakItem.end_time || ''
                }))
            }));
            
            // Save original state for revert
            originalAttendanceRecords = JSON.parse(JSON.stringify(attendanceRecords));

            renderRecords();
            hideStatus();
        }

        // Render all records
        function renderRecords() {
            const container = document.getElementById('attendance-records-container');
            
            if (attendanceRecords.length === 0) {
                container.innerHTML = `
                    <div class="empty-state">
                        <p>≈Ω√°dn√© z√°znamy doch√°zky</p>
                        <p>Kliknƒõte na "P≈ôidat z√°znam" pro vytvo≈ôen√≠ nov√©ho z√°znamu</p>
                    </div>
                `;
                return;
            }

            container.innerHTML = attendanceRecords.map((record, recordIndex) => {
                const isComplete = record.clock_in && record.clock_out;
                const badgeClass = isComplete ? 'status-valid' : 'status-invalid';
                const badgeText = isComplete ? 'Kompletn√≠' : 'Nekompletn√≠';
                
                return `
                <div class="record-card">
                    <div class="record-header">
                        <div class="record-title">
                            Z√°znam ${recordIndex + 1}
                            <span class="status-badge ${badgeClass}">${badgeText}</span>
                        </div>
                        <button class="remove-record-btn" onclick="removeAttendanceRecord(${recordIndex})">Odstranit</button>
                    </div>
                    <div class="time-inputs">
                        <div class="time-group">
                            <label>P≈ô√≠chod (HH:MM)</label>
                            <input 
                                type="time" 
                                value="${record.clock_in}" 
                                onchange="updateRecordField(${recordIndex}, 'clock_in', this.value)"
                                required
                            />
                        </div>
                        <div class="time-group">
                            <label>Odchod (HH:MM)</label>
                            <input 
                                type="time" 
                                value="${record.clock_out}" 
                                onchange="updateRecordField(${recordIndex}, 'clock_out', this.value)"
                            />
                        </div>
                    </div>
                    <div class="breaks-section">
                        <div class="breaks-header">
                            <div class="breaks-title">P≈ôest√°vky</div>
                            <button class="add-break-btn" onclick="addBreak(${recordIndex})">+ P≈ôidat p≈ôest√°vku</button>
                        </div>
                        ${record.breaks.map((breakItem, breakIndex) => `
                            <div class="break-item">
                                <div class="break-time-inputs">
                                    <div class="time-group">
                                        <label>Zaƒç√°tek</label>
                                        <input 
                                            type="time" 
                                            value="${breakItem.start_time}" 
                                            onchange="updateBreakField(${recordIndex}, ${breakIndex}, 'start_time', this.value)"
                                        />
                                    </div>
                                    <div class="time-group">
                                        <label>Konec</label>
                                        <input 
                                            type="time" 
                                            value="${breakItem.end_time}" 
                                            onchange="updateBreakField(${recordIndex}, ${breakIndex}, 'end_time', this.value)"
                                        />
                                    </div>
                                    <button class="remove-break-btn" onclick="removeBreak(${recordIndex}, ${breakIndex})">Odstranit</button>
                                </div>
                            </div>
                        `).join('')}
                        ${record.breaks.length === 0 ? '<p style="font-size: 12px; color: var(--tg-theme-hint-color, #999999);">≈Ω√°dn√© p≈ôest√°vky</p>' : ''}
                    </div>
                </div>
            `}).join('');
        }

        // Update record field
        function updateRecordField(recordIndex, field, value) {
            attendanceRecords[recordIndex][field] = value;
            // Validation on save only
            hideStatus();
        }

        // Update break field
        function updateBreakField(recordIndex, breakIndex, field, value) {
            attendanceRecords[recordIndex].breaks[breakIndex][field] = value;
            // Validation on save only
            hideStatus();
        }
        
        // Add new attendance record
        function addAttendanceRecord() {
            attendanceRecords.push({
                id: null,
                clock_in: '',
                clock_out: '',
                breaks: []
            });
            renderRecords();
            hideStatus();
        }

        // Remove attendance record
        function removeAttendanceRecord(index) {
            attendanceRecords.splice(index, 1);
            renderRecords();
            hideStatus();
        }

        // Add break to record
        function addBreak(recordIndex) {
            if (!attendanceRecords[recordIndex].breaks) {
                attendanceRecords[recordIndex].breaks = [];
            }
            attendanceRecords[recordIndex].breaks.push({
                id: null,
                start_time: '',
                end_time: ''
            });
            renderRecords();
            hideStatus();
        }

        // Remove break from record
        function removeBreak(recordIndex, breakIndex) {
            attendanceRecords[recordIndex].breaks.splice(breakIndex, 1);
            renderRecords();
            hideStatus();
        }

        // Reset data to original state
        function resetData() {
            if (confirm('Opravdu chcete zru≈°it v≈°echny neulo≈æen√© zmƒõny?')) {
                attendanceRecords = JSON.parse(JSON.stringify(originalAttendanceRecords));
                renderRecords();
                hideStatus();
                tg.HapticFeedback.notificationOccurred('warning');
            }
        }

        // Validate form
        function validateForm() {
            let isValid = true;
            const errors = [];

            // Helper to convert time string "HH:MM" to minutes since start of day
            const getMinutes = (timeStr) => {
                if (!timeStr) return null;
                const [h, m] = timeStr.split(':').map(Number);
                return h * 60 + m;
            };

            // Prepare processed records for overlap check
            const processedRecords = attendanceRecords.map((record, index) => {
                if (!record.clock_in) return null;
                
                let start = getMinutes(record.clock_in);
                let end = getMinutes(record.clock_out);
                let isOvernight = false;

                // Handle overnight: if end <= start, it ends the next day
                if (record.clock_out && end <= start) {
                    end += 24 * 60; // Add 24 hours
                    isOvernight = true;
                }
                
                return {
                    index: index,
                    start: start,
                    end: end, // can be null if not clocked out
                    isOvernight: isOvernight,
                    raw: record
                };
            }).filter(r => r !== null);

            // Check Overlaps between Shifts
            processedRecords.sort((a, b) => a.start - b.start);

            for (let i = 0; i < processedRecords.length - 1; i++) {
                const current = processedRecords[i];
                const next = processedRecords[i + 1];

                if (current.end !== null) {
                    if (current.end > next.start) {
                        isValid = false;
                        errors.push(`P≈ôekryv ƒçasu mezi Z√°znamem ${current.index + 1} (${current.raw.clock_in} - ${current.raw.clock_out}) a Z√°znamem ${next.index + 1} (${next.raw.clock_in}...)`);
                    }
                }
            }

            // Individual Record Validation
            attendanceRecords.forEach((record, recordIndex) => {
                if (!record.clock_in) {
                    isValid = false;
                    errors.push(`Z√°znam ${recordIndex + 1}: P≈ô√≠chod je povinn√Ω`);
                }

                // Break Validation
                const processedBreaks = [];
                
                record.breaks.forEach((breakItem, breakIndex) => {
                    if (breakItem.start_time && breakItem.end_time) {
                        let bStart = getMinutes(breakItem.start_time);
                        let bEnd = getMinutes(breakItem.end_time);
                        
                        // Auto-correct break crossing midnight (start > end)
                        if (bEnd <= bStart) {
                            bEnd += 24 * 60;
                        }

                        // Validate break end is after start
                        if (bEnd <= bStart) {
                            isValid = false;
                            errors.push(`Z√°znam ${recordIndex + 1}, P≈ôest√°vka ${breakIndex + 1}: Konec mus√≠ b√Ωt po zaƒç√°tku`);
                            return;
                        }
                        
                        processedBreaks.push({
                            index: breakIndex,
                            start: bStart,
                            end: bEnd,
                            raw: breakItem
                        });
                    }
                });

                // Check Overlaps between Breaks
                processedBreaks.sort((a, b) => a.start - b.start);
                
                for (let i = 0; i < processedBreaks.length - 1; i++) {
                    const currentBreak = processedBreaks[i];
                    const nextBreak = processedBreaks[i+1];
                    
                    if (currentBreak.end > nextBreak.start) {
                         isValid = false;
                         errors.push(`Z√°znam ${recordIndex + 1}: P≈ôest√°vky se p≈ôekr√Ωvaj√≠ (${currentBreak.raw.start_time}-${currentBreak.raw.end_time} a ${nextBreak.raw.start_time}...)`);
                    }
                }
            });

            if (errors.length > 0) {
                showError(errors.join('\n'));
            } else {
                hideStatus();
            }

            return isValid;
        }

        // Show error
        function showError(message) {
            const container = document.getElementById('status-container');
            container.innerHTML = `<div class="error">${message}</div>`;
        }

        // Show success
        function showSuccess(message) {
            const container = document.getElementById('status-container');
            container.innerHTML = `<div class="success-message">${message}</div>`;
        }

        // Hide status
        function hideStatus() {
            const container = document.getElementById('status-container');
            container.innerHTML = '';
        }

        // Show loading
        function showLoading(show) {
            const container = document.getElementById('loading-container');
            container.style.display = show ? 'block' : 'none';
            
            if (show) {
                tg.MainButton.showProgress();
            } else {
                tg.MainButton.hideProgress();
            }
        }

        // Save data via API
        async function saveData(closeAfter = false) {
            if (!validateForm()) {
                tg.showAlert('Pros√≠m opravte chyby ve formul√°≈ôi');
                return;
            }



            showLoading(true);

            const dataToSave = {
                date: currentDate,
                attendanceRecords: attendanceRecords.map(record => ({
                    id: record.id || undefined,
                    clock_in: record.clock_in,
                    clock_out: record.clock_out || undefined,
                    breaks: record.breaks.map(breakItem => ({
                        id: breakItem.id || undefined,
                        start_time: breakItem.start_time,
                        end_time: breakItem.end_time
                    })).filter(b => b.start_time && b.end_time)
                })).filter(r => r.clock_in)
            };

            // Debug: Check initData before saving
            console.log('[DEBUG] saveData called');
            console.log('[DEBUG] tg.initData at save time:', tg.initData);
            console.log('[DEBUG] tg.initData is empty?', !tg.initData || tg.initData.length === 0);
            
            if (!tg.initData || tg.initData.length === 0) {
                console.error('[ERROR] tg.initData is empty or undefined in saveData!');
                showError('Telegram authentication data is missing. Please open this app from Telegram.');
                showLoading(false);
                return;
            }
            
            try {
                const authHeader = tg.initData || '';
                console.log('[DEBUG] Sending Authorization header in POST, length:', authHeader.length);
                
                const response = await fetch(`${API_BASE_URL}/api/attendance`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': authHeader,
                        'ngrok-skip-browser-warning': 'true'
                    },
                    body: JSON.stringify(dataToSave)
                });
                
                // Check if response is actually JSON
                const contentType = response.headers.get('content-type');
                if (!contentType || !contentType.includes('application/json')) {
                    const text = await response.text();
                    if (text.trim().startsWith('<')) {
                        throw new Error('Server returned HTML instead of JSON. Please check if the Flask API server is running and the ngrok URL is correct.');
                    } else {
                        throw new Error(`Server returned unexpected content type: ${contentType}`);
                    }
                }
                
                if (!response.ok) {
                    try {
                        const errData = await response.json();
                        throw new Error(errData.error || `HTTP error! Status: ${response.status}`);
                    } catch (parseError) {
                        // If JSON parsing fails, use status code
                        throw new Error(`HTTP error! Status: ${response.status}`);
                    }
                }
                
                const result = await response.json();
                
                showSuccess(`Ulo≈æeno! (${result.message})`);
                tg.HapticFeedback.notificationOccurred('success');
                
                // Optionally refresh data to get IDs
                await fetchAttendance(currentDate);
                
                // Refresh invalid dates counter
                await fetchInvalidDates();

                if (closeAfter) {
                    setTimeout(() => {
                        tg.close();
                    }, 1000);
                }
                
            } catch (error) {
                console.error('Error saving attendance:', error);
                showError(`Chyba p≈ôi ukl√°d√°n√≠: ${error.message}`);
                tg.HapticFeedback.notificationOccurred('error');
            } finally {
                showLoading(false);
            }
        }

        // Set up save button
        tg.MainButton.onClick(saveData);

        // Initialize app
        initializeApp();
    </script>
</body>
</html>
